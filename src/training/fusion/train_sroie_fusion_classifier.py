# src/training/fusion/train_sroie_fusion_classifier.py

from pathlib import Path
from typing import List, Dict, Any, Tuple
import json

import numpy as np
import pandas as pd
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import (
    accuracy_score,
    precision_recall_fscore_support,
    confusion_matrix,
    classification_report,
)
import joblib

from src.config import PROCESSED_DIR

# --------------------------------------------------------------------
# Paths
# --------------------------------------------------------------------

# Project root, derived from PROCESSED_DIR = <root>/data/processed
PROJECT_ROOT = PROCESSED_DIR.parent.parent

# Where we will save the fusion model
MODELS_DIR = PROJECT_ROOT / "models"
FUSION_MODEL_PATH = MODELS_DIR / "fusion" / "sroie_fusion_clf.pkl"

# Path to the fusion dataset (generated by build_sroie_fusion_dataset.py)
FUSION_DATA_FILE = PROCESSED_DIR / "sroie_fusion_dataset.jsonl"


# --------------------------------------------------------------------
# Data loading
# --------------------------------------------------------------------

def load_fusion_dataset(path: Path) -> pd.DataFrame:
    """
    Load the fusion dataset from a JSONL file into a pandas DataFrame.

    Each line in the JSONL file is one record with keys like:
        - text
        - image_path
        - text_proba_real
        - text_proba_fraud
        - image_proba_real
        - image_proba_fraud
        - label
    """
    records: List[Dict[str, Any]] = []

    with path.open("r") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            record = json.loads(line)
            records.append(record)

    df = pd.DataFrame(records)
    print(f"Loaded {len(df)} fusion records.")
    print(f"Columns: {list(df.columns)}")
    return df


# --------------------------------------------------------------------
# Feature engineering
# --------------------------------------------------------------------

def build_features_and_labels(
    df: pd.DataFrame,
) -> Tuple[np.ndarray, np.ndarray, List[str]]:
    """
    Build the feature matrix X and label vector y from the fusion DataFrame.

    We use:
        - text_proba_real
        - text_proba_fraud
        - image_proba_real
        - image_proba_fraud
        plus simple margins (real - fraud) for text and image.
    """
    required_cols = [
        "text_proba_real",
        "text_proba_fraud",
        "image_proba_real",
        "image_proba_fraud",
        "label",
    ]
    missing = [c for c in required_cols if c not in df.columns]
    if missing:
        raise ValueError(f"Missing expected columns in fusion dataset: {missing}")

    # Base probabilities
    feature_names = [
        "text_proba_real",
        "text_proba_fraud",
        "image_proba_real",
        "image_proba_fraud",
    ]
    X_list = [
        df["text_proba_real"].values,
        df["text_proba_fraud"].values,
        df["image_proba_real"].values,
        df["image_proba_fraud"].values,
    ]

    # Simple margins: how confident each modality is towards "real"
    text_margin = df["text_proba_real"] - df["text_proba_fraud"]
    image_margin = df["image_proba_real"] - df["image_proba_fraud"]

    feature_names.extend(["text_margin", "image_margin"])
    X_list.append(text_margin.values)
    X_list.append(image_margin.values)

    # Final feature matrix and labels
    X = np.vstack(X_list).T  # shape: (n_samples, n_features)
    y = df["label"].astype(int).values

    print(f"Feature matrix shape: {X.shape}")
    print(f"Label vector shape:   {y.shape}")
    print(f"Features used: {feature_names}")

    return X, y, feature_names


# --------------------------------------------------------------------
# Training & evaluation
# --------------------------------------------------------------------

def train_fusion_model(X: np.ndarray, y: np.ndarray) -> None:
    """
    Train a simple logistic regression fusion classifier and save it to disk.
    """

    # Stratified train/validation split
    X_train, X_val, y_train, y_val = train_test_split(
        X,
        y,
        test_size=0.2,
        random_state=42,
        stratify=y if len(np.unique(y)) > 1 else None,
    )

    clf = LogisticRegression(
        max_iter=1000,
        n_jobs=-1,
        class_weight="balanced",  # handle potential class imbalance
    )

    print("\nFitting fusion logistic regression model...")
    clf.fit(X_train, y_train)

    # Evaluation on validation set
    y_pred = clf.predict(X_val)
    y_proba = clf.predict_proba(X_val)[:, 1]

    acc = accuracy_score(y_val, y_pred)
    precision, recall, f1, _ = precision_recall_fscore_support(
        y_val, y_pred, average="binary", zero_division=0
    )
    cm = confusion_matrix(y_val, y_pred)

    print("\n=== Fusion Model Evaluation (Validation set) ===")
    print(f"Accuracy : {acc:.4f}")
    print(f"Precision: {precision:.4f}")
    print(f"Recall   : {recall:.4f}")
    print(f"F1-score : {f1:.4f}")
    print("\nConfusion matrix (rows=true, cols=pred):")
    print(cm)
    print("\nClassification report:")
    print(classification_report(y_val, y_pred, digits=4, zero_division=0))

    # Save the trained model
    fusion_dir = MODELS_DIR / "fusion"
    fusion_dir.mkdir(parents=True, exist_ok=True)
    joblib.dump(clf, FUSION_MODEL_PATH)

    print(f"\nSaved fusion model to: {FUSION_MODEL_PATH}")


# --------------------------------------------------------------------
# Main entry point
# --------------------------------------------------------------------

def main() -> None:
    print("=== Training SROIE fusion classifier ===")
    print(f"Fusion dataset path: {FUSION_DATA_FILE}")
    print(f"Models will be saved under: {MODELS_DIR}")

    if not FUSION_DATA_FILE.exists():
        raise FileNotFoundError(f"Fusion dataset not found at: {FUSION_DATA_FILE}")

    # 1) Load fusion dataset
    df = load_fusion_dataset(FUSION_DATA_FILE)

    # 2) Build feature matrix X and label vector y
    X, y, feature_names = build_features_and_labels(df)

    # 3) Train model and save it
    train_fusion_model(X, y)


if __name__ == "__main__":
    main()
